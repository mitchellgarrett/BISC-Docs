## Arithnetic Instructions

### ADD - Add
\tformat{0x0E}

#### Desciption:
The `ADD` instruction adds the values of the two source registers and stores the result in the destination register.
Note that the addition is the same whether the inputs are interpreted as signed or unsigned values.
The destination register can be the same as one of the source registers to overwrite that register with the resulting sum, or all three registers can be the same to add a register to itself.

#### Action:
~~~
rd := rs0 + rs1
~~~

#### Assembler Syntax:
~~~
ADD {rd}, {rs0} {rs1}
~~~

#### Example:
~~~
; r0 = r1 + r2
ADD r0, r1, r2

; r0 = r1 + r0
ADD r0, r1, r0

; r0 = r0 + r0
ADD r0, r0, r0
~~~

### SUB - Subtract
\tformat{0x0F}

#### Desciption:
The `SUB` instruction subtracts the value of `rs~1~` from `rs~0~` and stores the result in the destination register.
Note that the subtraction is the same whether the inputs are interpreted as signed or unsigned values.
The destination register can be the same as one of the source registers to overwrite that register with the resulting difference, or all three registers can be the same to subtract a register from itself, but that would result in 0.

#### Action:
~~~
rd := rs0 - rs1
~~~

#### Assembler Syntax:
~~~
SUB {rd}, {rs0} {rs1}
~~~

#### Example:
~~~
; r0 = r1 - r2
SUB r0, r1, r2

; r0 = r1 - r0
SUB r0, r1, r0
~~~

### MUL - Multiply
\tformat{0x10}

#### Desciption:
The `MUL` instruction multiplies the values of `rs~0~` and `rs~1~` and stores the product in the destination register.
Note that `MUL` multiplies the lower 16 bits of the source register, so the result is the same whether the inputs are interpreted as signed or unsigned values.
16-bit multiplication results in a 32-bit value so the entirety of the destination register will be used.
The destination register can be the same as one of the source registers to overwrite that register with the resulting product, or all three registers can be the same to multiply a register by itself.

#### Action:
~~~
rd := rs0[0..15] $\cdot$ rs1[0..15]
~~~

#### Assembler Syntax:
~~~
MUL {rd}, {rs0} {rs1}
~~~

#### Example:
~~~
; r0 = r1 * r2
MUL r0, r1, r2

; r0 = r1 * r0
MUL r0, r1, r0
~~~

### MULH - Multiply High
\tformat{0x11}

#### Desciption:
The `MULH` instruction multiplies the upper 16 bits of `rs~0~` and `rs~1~` and stores the product in the destination register.
The upper 16 bits are interpreted as signed values, resulting in a different product than `MULHU`.
16-bit multiplication results in a 32-bit value so the entirety of the destination register will be used.
The destination register can be the same as one of the source registers to overwrite that register with the resulting product, or all three registers can be the same to multiply a register by itself.

#### Action:
~~~
rd := rs0[16..31] * rs1[16..31]
~~~

#### Assembler Syntax:
~~~
MULH {rd}, {rs0} {rs1}
~~~

#### Example:
~~~
; r0 = r1 * r2
MULH r0, r1, r2

; r0 = r1 * r0
MULH r0, r1, r0
~~~

### MULHU - Multiply High Unsigned
\tformat{0x12}

#### Desciption:
The `MULHU` instruction multiplies the upper 16 bits of `rs~0~` and `rs~1~` and stores the product in the destination register.
The upper 16 bits are interpreted as unsigned values, resulting in a different product than `MULH`.
16-bit multiplication results in a 32-bit value so the entirety of the destination register will be used.
The destination register can be the same as one of the source registers to overwrite that register with the resulting product, or all three registers can be the same to multiply a register by itself.

#### Action:
~~~
rd := rs0[16..31] * rs1[16..31]
~~~

#### Assembler Syntax:
~~~
MULHU {rd}, {rs0} {rs1}
~~~

#### Example:
~~~
; r0 = r1 * r2
MULHU r0, r1, r2

; r0 = r1 * r0
MULHU r0, r1, r0
~~~

### DIV - Divide
\tformat{0x13}

#### Desciption:
The `DIV` instruction divides `rs~0~` by `rs~1~` and stores the result in the destination register.
The source registers are interpreted as signed values, resulting in a different product than `DIVU`.
The destination register can be the same as one of the source registers to overwrite that register with the resulting quotient.

#### Action:
~~~
rd := rs0 / rs1
~~~

#### Assembler Syntax:
~~~
DIV {rd}, {rs0} {rs1}
~~~

#### Example:
~~~
; r0 = r1 / r2
DIV r0, r1, r2

; r0 = r1 / r0
DIV r0, r1, r0
~~~

### DIVU - Divide Unsigned
\tformat{0x14}

#### Desciption:
The `DIVU` instruction divides `rs~0~` by `rs~1~` and stores the result in the destination register.
The source registers are interpreted as unsigned values, resulting in a different product than `DIV`.
The destination register can be the same as one of the source registers to overwrite that register with the resulting quotient.

#### Action:
~~~
rd := rs0 / rs1
~~~

#### Assembler Syntax:
~~~
DIVU {rd}, {rs0} {rs1}
~~~

#### Example:
~~~
; r0 = r1 / r2
DIVU r0, r1, r2

; r0 = r1 / r0
DIVU r0, r1, r0
~~~

### MOD - Modulo
\tformat{0x15}

#### Desciption:
The `MOD` instruction conducts a modulus operation and divides `rs~0~` by `rs~1~` and stores the remainder of that division in the destination register.
The source registers are interpreted as signed values, resulting in a different product than `MODU`.

#### Action:
~~~
rd := rs0 % rs1
~~~

#### Assembler Syntax:
~~~
MOD {rd}, {rs0} {rs1}
~~~

#### Example:
~~~
; r0 = r1 % r2
MOD r0, r1, r2

; r0 = r1 % r0
MOD r0, r1, r0
~~~

### MODU - Modulo Unsigned
\tformat{0x16}

#### Desciption:
The `MODU` instruction conducts a modulus operation and divides `rs~0~` by `rs~1~` and stores the remainder of that division in the destination register.
The source registers are interpreted as unsigned values, resulting in a different product than `MOD`.

#### Action:
~~~
rd := rs0 % rs1
~~~

#### Assembler Syntax:
~~~
MODU {rd}, {rs0} {rs1}
~~~

#### Example:
~~~
; r0 = r1 % r2
MODU r0, r1, r2

; r0 = r1 % r0
MODU r0, r1, r0
~~~