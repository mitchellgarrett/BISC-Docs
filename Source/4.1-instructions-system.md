## System Instructions

### HLT - Halt
\nformat{0x00}

#### Desciption:
The `HLT` instruction signals to the CPU that the program is done and it should stop execution.
If the CPU does not encounter a HLT it will continue executing forever, so it is important to always end your program with one of these.
Note that HLT does not advance the program counter, so the value of \texttt{pc} will be the address of the HLT instruction.

#### Action:
~~~
Halt CPU execution
~~~

#### Assembler Syntax:
~~~
; halt program
HLT
~~~

### NOP - No Operation
\nformat{0x01}

#### Description:
The `NOP` instruction conducts 'No Operation', meaning it literally does nothing and advances the program counter by 4.
Why does this exist, you may ask? Well, NOPs can be very useful for padding out space in a program for timing purposes or as a debugging instruction to ensure the CPU is working correctly.
Apart from that it is unlikely that you will be using these often.

#### Action:
~~~
pc := pc + 4
~~~

#### Assembler Syntax:
~~~
; no operation
NOP
~~~

### SYS - System Call
\nformat{0x02}

#### Description:
The `SYS` instruction signals to the OS that it should handle a System Call.
The type of System Call to be executed is operating system-dependent and depends on the value of the `r0` register.
Registers `r1-r7` can be used as further arguments or be modified to store return values of the call, therefore you should read up on the specifics of your operating system and what the implications are of each System Call.

#### Action:
~~~
Execute system call
~~~

#### Assembler Syntax:
~~~
; load system call index into r0
LDI r0, {imm32}
; execute system call designated by r0
SYS
~~~

### CALL - Call Function
\nformat{0x03}

#### Description:
The `CALL` instruction executes a Function Call, storing the current value of the program counter in the return address register and changing the value of the program counter to the value of the `rd` register.
The specifics of how arguments are passed to a function are specified in the _Calling Convention_.

#### Action:
~~~
ra := pc
pc := rd
~~~

#### Assembler Syntax:
~~~
; load address of function to call
LDI {rd}, {imm32}
; pass execution to function
CALL {rd}
~~~

#### Example:
~~~
; load address of function
LDI r0, THIS_IS_A_FUNCTION
; call function
CALL r0
; this instruction will be run
; after function returns
HLT

; label of function
THIS_IS_A_FUNCTION:
RET
~~~

### RET - Return
\nformat{0x04}

#### Description:
The `RET` instruction returns from a function call, restoring the program counter to the stored value in the return address register.
This means you must be careful not to manipulate the value of `ra`.
Remember that each time the `CALL` instruction is executed the value of `ra` is changed, so calling a function inside of another function will corrupt it's value.
To get around this, follow the _Calling Convention_ to see how to push modified registers to the stack to save their values.

#### Action:
~~~
ra := pc
pc := rd
~~~

#### Assembler Syntax:
~~~
; return from function
RET
~~~

#### Example:
~~~
; load address of function
LDI r0, THIS_IS_A_FUNCTION
; call function
CALL r0
; this instruction will be run
; after function returns
HLT

; label of function
THIS_IS_A_FUNCTION:
; return from function
RET
~~~
